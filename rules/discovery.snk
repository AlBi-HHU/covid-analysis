### Helper Functions for File Aggregation


def fetchAllVCFDiffs(k, discoveryTool):
    list = []
    for run in barcodes:
        list += expand('data/auxiliary/discovery/' + discoveryTool + '/{method}/' + run + '/' + k + '/{barcode}.diff',
                       method=methods, barcode=barcodes[run])
    return list


def fetchAllPileups():
    list = []
    for run in barcodes:
        list += expand('data/auxiliary/pileupAnalysis/{method}/' + run + '/{barcode}.pileupanalysis.txt',
                       method=methods, barcode=barcodes[run])
    return list

### Snakemake Rules


rule freebayes_calling:
    input:
        ref = "data/input/nCoV-2019.reference.fasta",
        bam = 'data/auxiliary/realignment/{basecalling_method}/{run}/{k}/{barcode}.sorted.bam',

    output:
        vcf = 'data/auxiliary/discovery/freebayes/{basecalling_method}/{run}/{k}/{barcode}.vcf.raw',
        
    conda:
        '../envs/freebayes.yaml'

    shell:
        'freebayes -f {input.ref} {input.bam} -v {output.vcf}'
                        
        
rule freebayes_clean:
    input:
        vcf = 'data/auxiliary/discovery/freebayes/{basecalling_method}/{run}/{k}/{barcode}.vcf.raw',
    output:
        output = 'data/auxiliary/discovery/freebayes/{basecalling_method}/{run}/{k}/{barcode}.vcf.ugly',
    params:
        e_th = config["freebayesMaxEntropyTh"],
        ratio_ref_cov = config["feebayesMaxRefCovRatio"]
    conda:
        '../envs/freebayes.yaml'
    script:
        '../scripts/freebayes_filter.py'


rule realign_corrected_reads:
    input:
        index = 'data/input/nCoV-2019.reference.fasta.bwt',
        corrected = 'data/auxiliary/corrections/{basecalling_method}/{run}/{k}/{barcode}.fasta',
    output:
        'data/auxiliary/realignment/{basecalling_method}/{run}/{k}/{barcode}.sorted.bam'
    params:
        reference = 'data/input/nCoV-2019.reference.fasta'
    conda:
        '../envs/realign.yaml',
    log:
        'logs/{basecalling_method}_{run}_{barcode}_{k}_realign_corrected_reads.log'
    shell:
        'bwa mem {params.reference} {input.corrected} | samtools sort - > {output} 2> {log}'

rule variant_calling:
    input:
        ref = 'data/input/nCoV-2019.reference.fasta',
        bam = 'data/auxiliary/realignment/{run}/{k}/{barcode}.sorted.bam',
        bai = 'data/auxiliary/realignment/{run}/{k}/{barcode}.sorted.bam.bai'
    output:
        'data/auxiliary/realignment/{run}/{k}/{barcode}.snvs.vcf'
    conda:
        '../envs/realign.yaml',
    log:
        'logs/{run}_{barcode}_{k}_variant_calling.log'
    shell:
        "samtools mpileup -g -f {input.ref} {input.bam} | bcftools call -mv - | bcftools view --genotype het --types snps - > {output} 2> {log}"

# Misleading: The vcf_nanopolish is not really a vcf generated by nanopolish but rather a vcf based on samtools and realignment
rule generate_igv_Sessions:
    input:
        ref = 'data/input/nCoV-2019.reference.fasta',
        bam = 'data/auxiliary/realignment/{run}/{k}/{barcode}.sorted.bam',
        bai = 'data/auxiliary/realignment/{run}/{k}/{barcode}.sorted.bam.bai',
        vcf_medaka = 'data/auxiliary/realignment/medaka/{run}/{k}/{barcode}.snvs.vcf',
        vcf_nanopolish = 'data/auxiliary/realignment/nanopolish/{run}/{k}/{barcode}.snvs.vcf'
    output:
        report('data/output/IgvSessions/realignment/{run}/{k}/{barcode}.igv.xml', category='IGVSessions')
    conda:
        '../envs/perl.yaml'
    shell:
        'perl scripts/generate_IGV.pl --covidReference {input.ref} --BAM {input.bam} --output {output} --VCF_Medaka {input.vcf_medaka} --VCF_Nano {input.vcf_nanopolish}'

rule normalize_variant:
    input:
        ugly_variant = 'data/auxiliary/discovery/{prefix}.vcf.ugly',
        reference = "data/input/nCoV-2019.reference.fasta"
    output:
        variant = 'data/auxiliary/discovery/{prefix}.vcf',
    conda:
        '../envs/vt.yaml',
    log:
        'logs/pangenome_vc_normalize_variant_{prefix}_variant.log'
    shell:
        'if [ -s {input.ugly_variant} ]; then vt normalize -r {input.reference} -o {output.variant} {input.ugly_variant}; else touch {output.variant}; fi 2> {log}'
